#!/usr/bin/env python3
"""
Test Coverage Agent - Increase coverage from 57% â†’ 80%+
Focuses on under-tested critical modules
"""

import ast
import subprocess
from pathlib import Path
from typing import Dict, List, Any, Tuple


class TestCoverageAgent:
    """Analyzes code coverage and generates comprehensive tests."""
    
    def __init__(self, base_dir: str = "ghl_real_estate_ai"):
        self.base_dir = Path(base_dir)
        self.target_modules = [
            {"name": "bulk_operations", "file": "services/bulk_operations.py", "current": 11, "target": 80},
            {"name": "reengagement_engine", "file": "services/reengagement_engine.py", "current": 16, "target": 80},
            {"name": "memory_service", "file": "services/memory_service.py", "current": 25, "target": 80},
            {"name": "ghl_client", "file": "services/ghl_client.py", "current": 33, "target": 80}
        ]
        self.tests_created = []
    
    def analyze_module(self, module_path: Path) -> Dict[str, Any]:
        """Analyze module to identify untested code."""
        if not module_path.exists():
            return {"error": f"Module not found: {module_path}"}
        
        source = module_path.read_text()
        
        try:
            tree = ast.parse(source)
        except SyntaxError as e:
            return {"error": f"Syntax error: {e}"}
        
        analysis = {
            "classes": [],
            "functions": [],
            "async_functions": [],
            "total_lines": len(source.split('\n'))
        }
        
        for node in ast.walk(tree):
            if isinstance(node, ast.ClassDef):
                methods = [n.name for n in node.body if isinstance(n, (ast.FunctionDef, ast.AsyncFunctionDef))]
                analysis["classes"].append({
                    "name": node.name,
                    "methods": methods,
                    "method_count": len(methods)
                })
            elif isinstance(node, ast.FunctionDef):
                if not any(node in cls.body for cls in ast.walk(tree) if isinstance(cls, ast.ClassDef)):
                    analysis["functions"].append(node.name)
            elif isinstance(node, ast.AsyncFunctionDef):
                if not any(node in cls.body for cls in ast.walk(tree) if isinstance(cls, ast.ClassDef)):
                    analysis["async_functions"].append(node.name)
        
        return analysis
    
    def generate_test_template(self, module_info: Dict[str, Any], analysis: Dict[str, Any]) -> str:
        """Generate test template for a module."""
        module_name = module_info["name"]
        
        test_content = f'''"""
Additional tests for {module_name} to increase coverage from {module_info["current"]}% â†’ {module_info["target"]}%
Generated by Test Coverage Agent
"""

import pytest
from unittest.mock import Mock, patch, MagicMock
from ghl_real_estate_ai.services.{module_name} import *


class Test{module_name.replace("_", "").title()}Extended:
    """Extended test coverage for {module_name}."""
    
    @pytest.fixture
    def setup(self):
        """Setup test fixtures."""
        # TODO: Add necessary fixtures
        pass
    
'''
        
        # Generate tests for each class
        for cls in analysis.get("classes", []):
            test_content += f'''
    # Tests for {cls["name"]}
    
'''
            for method in cls["methods"][:3]:  # First 3 methods as examples
                test_content += f'''    def test_{cls["name"].lower()}_{method}(self, setup):
        """Test {cls["name"]}.{method} method."""
        # TODO: Implement test
        pytest.skip("Test template - needs implementation")
    
'''
        
        # Generate tests for standalone functions
        for func in analysis.get("functions", [])[:3]:
            test_content += f'''    def test_{func}(self, setup):
        """Test {func} function."""
        # TODO: Implement test
        pytest.skip("Test template - needs implementation")
    
'''
        
        # Generate tests for async functions
        for func in analysis.get("async_functions", [])[:3]:
            test_content += f'''    @pytest.mark.asyncio
    async def test_{func}(self, setup):
        """Test {func} async function."""
        # TODO: Implement test
        pytest.skip("Test template - needs implementation")
    
'''
        
        return test_content
    
    def run_coverage(self) -> Dict[str, Any]:
        """Run pytest with coverage to get current metrics."""
        try:
            result = subprocess.run(
                ["python3", "-m", "pytest", "tests/", "--cov=ghl_real_estate_ai", 
                 "--cov-report=json", "--cov-report=term-missing", "-q"],
                cwd=self.base_dir,
                capture_output=True,
                text=True,
                timeout=120
            )
            
            # Try to read coverage.json
            coverage_file = self.base_dir / "coverage.json"
            if coverage_file.exists():
                import json
                return json.loads(coverage_file.read_text())
            else:
                return {"error": "Coverage file not found"}
                
        except subprocess.TimeoutExpired:
            return {"error": "Coverage run timed out"}
        except Exception as e:
            return {"error": f"Coverage run failed: {str(e)}"}
    
    def process_all_modules(self) -> List[Dict[str, Any]]:
        """Process all target modules."""
        results = []
        
        for module_info in self.target_modules:
            module_path = self.base_dir / module_info["file"]
            
            print(f"\nğŸ“Š Analyzing {module_info['name']}...")
            print(f"   Current coverage: {module_info['current']}%")
            print(f"   Target coverage: {module_info['target']}%")
            print(f"   Gap: {module_info['target'] - module_info['current']}%")
            
            analysis = self.analyze_module(module_path)
            
            if "error" in analysis:
                results.append({
                    "module": module_info["name"],
                    "status": "error",
                    "error": analysis["error"]
                })
                continue
            
            print(f"   Classes found: {len(analysis['classes'])}")
            print(f"   Functions found: {len(analysis['functions'])}")
            print(f"   Async functions found: {len(analysis['async_functions'])}")
            
            # Generate test template
            test_content = self.generate_test_template(module_info, analysis)
            test_file = self.base_dir / "tests" / f"test_{module_info['name']}_extended.py"
            
            results.append({
                "module": module_info["name"],
                "status": "template_generated",
                "test_file": str(test_file),
                "analysis": analysis,
                "test_content": test_content
            })
        
        return results
    
    def generate_report(self, results: List[Dict[str, Any]]) -> str:
        """Generate coverage improvement report."""
        report = []
        report.append("=" * 80)
        report.append("TEST COVERAGE AGENT REPORT")
        report.append("=" * 80)
        report.append("")
        
        report.append("ğŸ“Š Target Modules:")
        report.append("")
        
        for module_info in self.target_modules:
            gap = module_info["target"] - module_info["current"]
            report.append(f"  â€¢ {module_info['name']}")
            report.append(f"    Current: {module_info['current']}% | Target: {module_info['target']}% | Gap: {gap}%")
        
        report.append("")
        report.append("ğŸ“‹ Analysis Results:")
        report.append("")
        
        for result in results:
            if result["status"] == "template_generated":
                analysis = result["analysis"]
                report.append(f"  âœ… {result['module']}")
                report.append(f"     Test template: {result['test_file']}")
                report.append(f"     Classes: {len(analysis.get('classes', []))}")
                report.append(f"     Functions: {len(analysis.get('functions', []))}")
                report.append(f"     Lines: {analysis.get('total_lines', 0)}")
            else:
                report.append(f"  âŒ {result['module']}: {result.get('error', 'Unknown error')}")
            report.append("")
        
        report.append("=" * 80)
        report.append("ğŸ“ NEXT STEPS:")
        report.append("")
        report.append("1. Review generated test templates in tests/*_extended.py")
        report.append("2. Implement actual test logic (replace pytest.skip)")
        report.append("3. Run: pytest tests/test_*_extended.py -v")
        report.append("4. Run coverage: pytest --cov=ghl_real_estate_ai tests/")
        report.append("5. Iterate until 80% coverage achieved")
        report.append("=" * 80)
        
        return "\n".join(report)


def main():
    """Run test coverage agent."""
    print("ğŸ§ª Test Coverage Agent Starting...\n")
    
    agent = TestCoverageAgent()
    
    # Process all modules
    results = agent.process_all_modules()
    
    # Generate report
    report = agent.generate_report(results)
    print("\n" + report)
    
    # Save report
    report_path = Path("ghl_real_estate_ai") / "TEST_COVERAGE_REPORT.md"
    report_path.write_text(report)
    print(f"\nğŸ“„ Report saved to: {report_path}")
    
    # Save test templates
    print("\nğŸ’¾ Saving test templates...")
    for result in results:
        if result["status"] == "template_generated":
            test_file = Path(result["test_file"])
            test_file.write_text(result["test_content"])
            print(f"   âœ… {test_file}")
    
    print("\nâœ¨ Test templates generated! Review and implement them to increase coverage.")


if __name__ == "__main__":
    main()
