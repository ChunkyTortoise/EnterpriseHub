"""
Proactive Intelligence Engine - Smart Notifications & Predictive Analytics
Provides proactive alerts, predictive insights, and continuous background monitoring.
"""

import asyncio
import json
import logging
import time
from dataclasses import asdict, dataclass
from datetime import datetime, timedelta
from enum import Enum
from typing import Any, Dict, List, Optional, Tuple

from ghl_real_estate_ai.ghl_utils.logger import get_logger

logger = get_logger(__name__)


class AlertPriority(Enum):
    """Alert priority levels."""

    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"


class AlertType(Enum):
    """Types of proactive alerts."""

    OPPORTUNITY = "opportunity"
    RISK = "risk"
    PERFORMANCE = "performance"
    MARKET = "market"
    LEAD_BEHAVIOR = "lead_behavior"
    TIMING = "timing"
    SYSTEM = "system"


@dataclass
class ProactiveAlert:
    """A proactive alert generated by the intelligence engine."""

    alert_id: str
    alert_type: AlertType
    priority: AlertPriority
    title: str
    description: str
    action_items: List[str]
    trigger_data: Dict[str, Any]
    timestamp: datetime
    expires_at: Optional[datetime]
    lead_id: Optional[str] = None
    confidence: float = 0.8
    seen: bool = False
    acted_upon: bool = False


@dataclass
class PredictiveInsight:
    """Predictive analytics insight."""

    insight_id: str
    insight_type: str  # "optimal_contact_time", "closing_probability", "churn_risk", etc.
    prediction: Any  # The actual prediction (time, probability, score, etc.)
    confidence: float
    reasoning: str
    recommended_actions: List[str]
    valid_until: datetime
    lead_id: Optional[str] = None
    market_context: Dict[str, Any] = None


@dataclass
class PerformanceCoachingTip:
    """Real-time performance coaching suggestion."""

    tip_id: str
    category: str  # "communication", "timing", "strategy", "follow_up"
    title: str
    description: str
    impact_level: str  # "high", "medium", "low"
    implementation_effort: str  # "immediate", "short_term", "long_term"
    success_metrics: List[str]
    timestamp: datetime


class ProactiveIntelligenceEngine:
    """
    Advanced proactive intelligence engine for real estate AI.

    Features:
    - Smart notification system with priority-based alerts
    - Predictive analytics for optimal timing and strategies
    - Continuous background monitoring of leads and market
    - Real-time performance coaching and optimization
    - Machine learning-powered insights and recommendations
    """

    def __init__(self):
        self.active_alerts: List[ProactiveAlert] = []
        self.predictive_insights: Dict[str, PredictiveInsight] = {}
        self.coaching_tips: List[PerformanceCoachingTip] = []
        self.monitoring_active = False
        self.alert_history: List[ProactiveAlert] = []

        # Configuration
        self.max_active_alerts = 10
        self.alert_expiry_hours = 24
        self.monitoring_interval_seconds = 300  # 5 minutes
        self.prediction_cache_minutes = 30

        logger.info("Proactive Intelligence Engine initialized")

    async def start_background_monitoring(self) -> bool:
        """
        Start continuous background monitoring for proactive intelligence.

        Returns:
            bool: True if monitoring started successfully
        """
        try:
            if self.monitoring_active:
                logger.warning("Background monitoring already active")
                return True

            self.monitoring_active = True
            logger.info("Starting proactive intelligence background monitoring")

            # Start monitoring tasks
            asyncio.create_task(self._continuous_monitoring_loop())
            asyncio.create_task(self._predictive_analysis_loop())
            asyncio.create_task(self._performance_coaching_loop())

            return True

        except Exception as e:
            logger.error(f"Failed to start background monitoring: {e}")
            self.monitoring_active = False
            return False

    async def stop_background_monitoring(self) -> None:
        """Stop background monitoring."""
        self.monitoring_active = False
        logger.info("Proactive intelligence background monitoring stopped")

    async def generate_smart_notifications(self, context: Dict[str, Any]) -> List[ProactiveAlert]:
        """
        Generate smart notifications based on current context and data.

        Args:
            context: Current platform context (leads, activities, performance, etc.)

        Returns:
            List of new proactive alerts
        """
        try:
            new_alerts = []

            # Lead behavior analysis
            lead_alerts = await self._analyze_lead_behaviors(context)
            new_alerts.extend(lead_alerts)

            # Performance monitoring
            performance_alerts = await self._monitor_performance_metrics(context)
            new_alerts.extend(performance_alerts)

            # Market opportunity detection
            market_alerts = await self._detect_market_opportunities(context)
            new_alerts.extend(market_alerts)

            # Timing optimization alerts
            timing_alerts = await self._analyze_optimal_timing(context)
            new_alerts.extend(timing_alerts)

            # Risk assessment alerts
            risk_alerts = await self._assess_risks(context)
            new_alerts.extend(risk_alerts)

            # Add new alerts to active list
            for alert in new_alerts:
                await self._add_alert(alert)

            logger.info(f"Generated {len(new_alerts)} smart notifications")
            return new_alerts

        except Exception as e:
            logger.error(f"Error generating smart notifications: {e}")
            return []

    async def get_predictive_insights(self, lead_id: Optional[str] = None) -> List[PredictiveInsight]:
        """
        Get predictive analytics insights.

        Args:
            lead_id: Optional lead ID to get specific insights for

        Returns:
            List of predictive insights
        """
        try:
            insights = []

            if lead_id:
                # Get insights for specific lead
                lead_insights = await self._predict_lead_outcomes(lead_id)
                insights.extend(lead_insights)
            else:
                # Get general insights
                general_insights = await self._predict_general_outcomes()
                insights.extend(general_insights)

            # Cache insights
            for insight in insights:
                self.predictive_insights[insight.insight_id] = insight

            return insights

        except Exception as e:
            logger.error(f"Error getting predictive insights: {e}")
            return []

    async def get_performance_coaching(self, performance_data: Dict[str, Any]) -> List[PerformanceCoachingTip]:
        """
        Generate real-time performance coaching tips.

        Args:
            performance_data: Current performance metrics and context

        Returns:
            List of performance coaching tips
        """
        try:
            coaching_tips = []

            # Communication analysis
            comm_tips = await self._analyze_communication_patterns(performance_data)
            coaching_tips.extend(comm_tips)

            # Strategy optimization
            strategy_tips = await self._optimize_strategies(performance_data)
            coaching_tips.extend(strategy_tips)

            # Time management insights
            timing_tips = await self._analyze_time_management(performance_data)
            coaching_tips.extend(timing_tips)

            # Follow-up optimization
            followup_tips = await self._optimize_followup_strategies(performance_data)
            coaching_tips.extend(followup_tips)

            # Store tips
            self.coaching_tips.extend(coaching_tips)

            return coaching_tips

        except Exception as e:
            logger.error(f"Error generating performance coaching: {e}")
            return []

    async def get_active_alerts(self, priority_filter: Optional[AlertPriority] = None) -> List[ProactiveAlert]:
        """
        Get currently active alerts.

        Args:
            priority_filter: Optional filter by priority level

        Returns:
            List of active alerts
        """
        try:
            # Clean expired alerts
            await self._cleanup_expired_alerts()

            alerts = self.active_alerts.copy()

            if priority_filter:
                alerts = [alert for alert in alerts if alert.priority == priority_filter]

            # Sort by priority and timestamp
            priority_order = {
                AlertPriority.CRITICAL: 0,
                AlertPriority.HIGH: 1,
                AlertPriority.MEDIUM: 2,
                AlertPriority.LOW: 3,
                AlertPriority.INFO: 4,
            }

            alerts.sort(key=lambda x: (priority_order[x.priority], x.timestamp), reverse=True)

            return alerts

        except Exception as e:
            logger.error(f"Error getting active alerts: {e}")
            return []

    async def mark_alert_seen(self, alert_id: str) -> bool:
        """Mark an alert as seen by the user."""
        try:
            for alert in self.active_alerts:
                if alert.alert_id == alert_id:
                    alert.seen = True
                    logger.info(f"Alert {alert_id} marked as seen")
                    return True
            return False
        except Exception as e:
            logger.error(f"Error marking alert as seen: {e}")
            return False

    async def mark_alert_acted_upon(self, alert_id: str) -> bool:
        """Mark an alert as acted upon by the user."""
        try:
            for alert in self.active_alerts:
                if alert.alert_id == alert_id:
                    alert.acted_upon = True
                    alert.seen = True
                    logger.info(f"Alert {alert_id} marked as acted upon")
                    return True
            return False
        except Exception as e:
            logger.error(f"Error marking alert as acted upon: {e}")
            return False

    # =======================
    # PRIVATE ANALYSIS METHODS
    # =======================

    async def _continuous_monitoring_loop(self) -> None:
        """Continuous monitoring background task."""
        while self.monitoring_active:
            try:
                # Simulate continuous monitoring
                await asyncio.sleep(self.monitoring_interval_seconds)

                if not self.monitoring_active:
                    break

                # Generate context from current state
                monitoring_context = await self._get_monitoring_context()

                # Generate alerts based on monitoring
                await self.generate_smart_notifications(monitoring_context)

            except Exception as e:
                logger.error(f"Error in continuous monitoring loop: {e}")

    async def _predictive_analysis_loop(self) -> None:
        """Predictive analysis background task."""
        while self.monitoring_active:
            try:
                await asyncio.sleep(self.prediction_cache_minutes * 60)

                if not self.monitoring_active:
                    break

                # Generate predictive insights
                await self.get_predictive_insights()

            except Exception as e:
                logger.error(f"Error in predictive analysis loop: {e}")

    async def _performance_coaching_loop(self) -> None:
        """Performance coaching background task."""
        while self.monitoring_active:
            try:
                await asyncio.sleep(300)  # 5 minutes

                if not self.monitoring_active:
                    break

                # Generate performance coaching
                performance_data = await self._get_performance_data()
                await self.get_performance_coaching(performance_data)

            except Exception as e:
                logger.error(f"Error in performance coaching loop: {e}")

    async def _analyze_lead_behaviors(self, context: Dict[str, Any]) -> List[ProactiveAlert]:
        """Analyze lead behaviors for alerts."""
        alerts = []

        # Simulated lead behavior analysis
        leads = context.get("leads", [])

        for lead in leads[:3]:  # Analyze top 3 leads
            lead_name = lead.get("name", "Unknown Lead")
            last_contact = lead.get("last_contact_hours", 0)

            # Hot lead cooling alert
            if last_contact > 72:  # 3 days
                alert = ProactiveAlert(
                    alert_id=f"cooling_risk_{int(time.time())}",
                    alert_type=AlertType.RISK,
                    priority=AlertPriority.HIGH,
                    title=f"ðŸ”¥âž¡ï¸â„ï¸ Hot Lead Cooling: {lead_name}",
                    description=f"{lead_name} hasn't been contacted in {last_contact} hours. Risk of lead going cold.",
                    action_items=[
                        f"Contact {lead_name} immediately",
                        "Send personalized follow-up message",
                        "Offer value-add content or insight",
                    ],
                    trigger_data={"lead_id": lead.get("id"), "hours_since_contact": last_contact},
                    timestamp=datetime.now(),
                    expires_at=datetime.now() + timedelta(hours=12),
                    lead_id=lead.get("id"),
                )
                alerts.append(alert)

            # High engagement opportunity
            elif lead.get("engagement_score", 0) > 0.8:
                alert = ProactiveAlert(
                    alert_id=f"high_engagement_{int(time.time())}",
                    alert_type=AlertType.OPPORTUNITY,
                    priority=AlertPriority.HIGH,
                    title=f"ðŸš€ High Engagement: {lead_name}",
                    description=f"{lead_name} showing exceptional engagement (85%+). Perfect time to push for meeting.",
                    action_items=[
                        f"Schedule viewing with {lead_name} today",
                        "Prepare premium property options",
                        "Draft closing-focused conversation plan",
                    ],
                    trigger_data={"lead_id": lead.get("id"), "engagement_score": lead.get("engagement_score")},
                    timestamp=datetime.now(),
                    expires_at=datetime.now() + timedelta(hours=6),
                    lead_id=lead.get("id"),
                )
                alerts.append(alert)

        return alerts

    async def _monitor_performance_metrics(self, context: Dict[str, Any]) -> List[ProactiveAlert]:
        """Monitor performance metrics for alerts."""
        alerts = []

        performance = context.get("performance", {})

        # Conversion rate drop alert
        current_conversion = performance.get("conversion_rate", 0.15)
        target_conversion = 0.20

        if current_conversion < target_conversion * 0.8:  # 20% below target
            alert = ProactiveAlert(
                alert_id=f"conversion_drop_{int(time.time())}",
                alert_type=AlertType.PERFORMANCE,
                priority=AlertPriority.MEDIUM,
                title="ðŸ“‰ Conversion Rate Below Target",
                description=f"Current conversion rate ({current_conversion:.1%}) is below target ({target_conversion:.1%})",
                action_items=[
                    "Review recent lead qualification process",
                    "Analyze lost opportunities for patterns",
                    "Schedule coaching session on closing techniques",
                ],
                trigger_data={"current_rate": current_conversion, "target_rate": target_conversion},
                timestamp=datetime.now(),
                expires_at=datetime.now() + timedelta(days=2),
            )
            alerts.append(alert)

        return alerts

    async def _detect_market_opportunities(self, context: Dict[str, Any]) -> List[ProactiveAlert]:
        """Detect market opportunities for alerts."""
        alerts = []

        market_data = context.get("market", {})

        # Interest rate opportunity
        if market_data.get("interest_rate_trend") == "dropping":
            alert = ProactiveAlert(
                alert_id=f"rate_opportunity_{int(time.time())}",
                alert_type=AlertType.MARKET,
                priority=AlertPriority.MEDIUM,
                title="ðŸ’° Interest Rate Opportunity",
                description="Interest rates dropping - perfect time to contact fence-sitting buyers",
                action_items=[
                    "Contact warm leads about rate changes",
                    "Emphasize urgency in financing conversations",
                    "Prepare rate comparison materials",
                ],
                trigger_data={"trend": "dropping", "impact": "buyer_motivation"},
                timestamp=datetime.now(),
                expires_at=datetime.now() + timedelta(days=3),
            )
            alerts.append(alert)

        return alerts

    async def _analyze_optimal_timing(self, context: Dict[str, Any]) -> List[ProactiveAlert]:
        """Analyze optimal timing for alerts."""
        alerts = []

        current_hour = datetime.now().hour

        # Optimal calling window
        if 9 <= current_hour <= 11:  # Prime calling hours
            alert = ProactiveAlert(
                alert_id=f"prime_time_{int(time.time())}",
                alert_type=AlertType.TIMING,
                priority=AlertPriority.INFO,
                title="â° Prime Calling Hours",
                description="Now is optimal time for lead outreach (9-11 AM)",
                action_items=[
                    "Make priority lead calls now",
                    "Focus on warm leads first",
                    "Use this window for important conversations",
                ],
                trigger_data={"hour": current_hour, "window": "prime_calling"},
                timestamp=datetime.now(),
                expires_at=datetime.now() + timedelta(hours=2),
            )
            alerts.append(alert)

        return alerts

    async def _assess_risks(self, context: Dict[str, Any]) -> List[ProactiveAlert]:
        """Assess risks for alerts."""
        alerts = []

        # Pipeline risk assessment
        pipeline_value = context.get("pipeline_value", 0)
        monthly_target = context.get("monthly_target", 100000)

        if pipeline_value < monthly_target * 0.6:  # Pipeline below 60% of target
            alert = ProactiveAlert(
                alert_id=f"pipeline_risk_{int(time.time())}",
                alert_type=AlertType.RISK,
                priority=AlertPriority.HIGH,
                title="âš ï¸ Pipeline Risk: Below Target",
                description=f"Pipeline value (${pipeline_value:,}) below 60% of monthly target (${monthly_target:,})",
                action_items=[
                    "Accelerate lead generation activities",
                    "Focus on high-value opportunities",
                    "Consider additional marketing spend",
                ],
                trigger_data={"pipeline_value": pipeline_value, "target": monthly_target},
                timestamp=datetime.now(),
                expires_at=datetime.now() + timedelta(days=7),
            )
            alerts.append(alert)

        return alerts

    async def _predict_lead_outcomes(self, lead_id: str) -> List[PredictiveInsight]:
        """Predict outcomes for specific lead."""
        insights = []

        # Simulated predictive analysis
        closing_probability = 0.73
        optimal_contact_time = "Tuesday 10:00 AM"
        churn_risk = 0.15

        # Closing probability insight
        closing_insight = PredictiveInsight(
            insight_id=f"closing_prob_{lead_id}_{int(time.time())}",
            insight_type="closing_probability",
            prediction=closing_probability,
            confidence=0.85,
            reasoning="High engagement score, quick response time, and budget alignment indicate strong closing potential",
            recommended_actions=[
                "Schedule in-person meeting within 48 hours",
                "Prepare premium property options",
                "Draft purchase agreement template",
            ],
            valid_until=datetime.now() + timedelta(days=7),
            lead_id=lead_id,
        )
        insights.append(closing_insight)

        # Optimal contact time insight
        timing_insight = PredictiveInsight(
            insight_id=f"contact_time_{lead_id}_{int(time.time())}",
            insight_type="optimal_contact_time",
            prediction=optimal_contact_time,
            confidence=0.78,
            reasoning="Analysis of past response patterns shows highest engagement on Tuesday mornings",
            recommended_actions=[
                f"Schedule next call for {optimal_contact_time}",
                "Prepare agenda for high-impact conversation",
                "Set reminder 15 minutes before call",
            ],
            valid_until=datetime.now() + timedelta(days=1),
            lead_id=lead_id,
        )
        insights.append(timing_insight)

        return insights

    async def _predict_general_outcomes(self) -> List[PredictiveInsight]:
        """Predict general market and performance outcomes."""
        insights = []

        # Market trend prediction
        market_insight = PredictiveInsight(
            insight_id=f"market_trend_{int(time.time())}",
            insight_type="market_trend",
            prediction="uptick_in_buyer_activity",
            confidence=0.82,
            reasoning="Interest rate stabilization and seasonal patterns indicate increased buyer activity next week",
            recommended_actions=[
                "Increase lead generation budget by 20%",
                "Prepare additional property inventory",
                "Schedule extra showings availability",
            ],
            valid_until=datetime.now() + timedelta(days=10),
            market_context={"trend_direction": "up", "confidence": "high"},
        )
        insights.append(market_insight)

        return insights

    async def _analyze_communication_patterns(self, performance_data: Dict[str, Any]) -> List[PerformanceCoachingTip]:
        """Analyze communication patterns for coaching."""
        tips = []

        avg_response_time = performance_data.get("avg_response_time_hours", 4)

        if avg_response_time > 2:
            tip = PerformanceCoachingTip(
                tip_id=f"response_time_{int(time.time())}",
                category="communication",
                title="âš¡ Improve Response Speed",
                description=f"Your average response time ({avg_response_time} hours) could be improved. Faster responses increase engagement by 40%.",
                impact_level="high",
                implementation_effort="immediate",
                success_metrics=[
                    "Response time under 2 hours",
                    "Engagement rate increase",
                    "Lead conversion improvement",
                ],
                timestamp=datetime.now(),
            )
            tips.append(tip)

        return tips

    async def _optimize_strategies(self, performance_data: Dict[str, Any]) -> List[PerformanceCoachingTip]:
        """Optimize strategies for coaching."""
        tips = []

        closing_rate = performance_data.get("closing_rate", 0.15)

        if closing_rate < 0.20:
            tip = PerformanceCoachingTip(
                tip_id=f"closing_strategy_{int(time.time())}",
                category="strategy",
                title="ðŸŽ¯ Enhance Closing Techniques",
                description="Your closing rate could be improved with advanced closing strategies and better objection handling.",
                impact_level="high",
                implementation_effort="short_term",
                success_metrics=["Closing rate above 20%", "Objection handling confidence", "Deal velocity increase"],
                timestamp=datetime.now(),
            )
            tips.append(tip)

        return tips

    async def _analyze_time_management(self, performance_data: Dict[str, Any]) -> List[PerformanceCoachingTip]:
        """Analyze time management for coaching."""
        tips = []

        # Time allocation analysis
        tip = PerformanceCoachingTip(
            tip_id=f"time_mgmt_{int(time.time())}",
            category="timing",
            title="â° Optimize Time Allocation",
            description="Focus 60% of time on warm leads, 30% on follow-ups, 10% on cold outreach for maximum ROI.",
            impact_level="medium",
            implementation_effort="immediate",
            success_metrics=["Improved time efficiency", "Higher quality interactions", "Better conversion rates"],
            timestamp=datetime.now(),
        )
        tips.append(tip)

        return tips

    async def _optimize_followup_strategies(self, performance_data: Dict[str, Any]) -> List[PerformanceCoachingTip]:
        """Optimize follow-up strategies for coaching."""
        tips = []

        followup_rate = performance_data.get("followup_completion_rate", 0.7)

        if followup_rate < 0.85:
            tip = PerformanceCoachingTip(
                tip_id=f"followup_opt_{int(time.time())}",
                category="follow_up",
                title="ðŸ“‹ Improve Follow-up Consistency",
                description="Consistent follow-ups increase conversion by 50%. Automate reminders and templates.",
                impact_level="medium",
                implementation_effort="short_term",
                success_metrics=[
                    "Follow-up completion above 85%",
                    "Lead nurturing improvement",
                    "Conversion rate increase",
                ],
                timestamp=datetime.now(),
            )
            tips.append(tip)

        return tips

    async def _add_alert(self, alert: ProactiveAlert) -> None:
        """Add alert to active list with limit management."""
        self.active_alerts.append(alert)

        # Maintain alert limit
        if len(self.active_alerts) > self.max_active_alerts:
            # Remove oldest low-priority alerts
            self.active_alerts.sort(key=lambda x: (x.priority.value, x.timestamp))
            self.active_alerts = self.active_alerts[-self.max_active_alerts :]

    async def _cleanup_expired_alerts(self) -> None:
        """Remove expired alerts."""
        now = datetime.now()
        self.active_alerts = [
            alert for alert in self.active_alerts if alert.expires_at is None or alert.expires_at > now
        ]

    async def _get_monitoring_context(self) -> Dict[str, Any]:
        """Get context for monitoring."""
        return {
            "leads": [
                {"id": "lead_1", "name": "Sarah Martinez", "last_contact_hours": 76, "engagement_score": 0.65},
                {"id": "lead_2", "name": "David Kim", "last_contact_hours": 12, "engagement_score": 0.87},
                {"id": "lead_3", "name": "Maria Rodriguez", "last_contact_hours": 168, "engagement_score": 0.45},
            ],
            "performance": {
                "conversion_rate": 0.14,
                "avg_response_time_hours": 3.2,
                "closing_rate": 0.16,
                "followup_completion_rate": 0.73,
            },
            "market": {"interest_rate_trend": "dropping", "buyer_activity": "high"},
            "pipeline_value": 75000,
            "monthly_target": 150000,
        }

    async def _get_performance_data(self) -> Dict[str, Any]:
        """Get performance data for coaching."""
        return {
            "avg_response_time_hours": 3.2,
            "closing_rate": 0.16,
            "followup_completion_rate": 0.73,
            "calls_per_day": 8,
            "meetings_scheduled": 3,
        }


# Global intelligence engine instance
_intelligence_engine = None


def get_proactive_intelligence_engine() -> ProactiveIntelligenceEngine:
    """Get global proactive intelligence engine instance."""
    global _intelligence_engine
    if _intelligence_engine is None:
        _intelligence_engine = ProactiveIntelligenceEngine()
    return _intelligence_engine
