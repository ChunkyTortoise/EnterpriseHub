"""
Enterprise Security Extended Tests
Generated by Agent 6: Test Coverage Implementation
Target: 80%+ coverage for security modules
"""

import asyncio
from datetime import datetime, timedelta
from unittest.mock import AsyncMock, MagicMock, Mock, patch

import pytest
from fastapi import HTTPException, Request, Response, status

from ghl_real_estate_ai.security.auth_manager import (
    AuthManager,
    AuthProvider,
    Role,
    SecurityConfig,
    Session,
    SessionStatus,
    User,
)
from ghl_real_estate_ai.security.security_middleware import SecurityHeaders, SecurityMiddleware


@pytest.mark.asyncio
class TestAuthManager:
    """Tests for Enterprise AuthManager."""

    @pytest.fixture(autouse=True)
    def integration_test_lifecycle(self):
        """Override integration test lifecycle to avoid async conflict."""
        yield

    @pytest.fixture
    def config(self):
        return SecurityConfig(jwt_secret_key="test_secret", max_failed_attempts=3, lockout_duration_minutes=5)

    @pytest.fixture
    def mock_redis(self):
        mock = AsyncMock()
        mock.set = AsyncMock()
        mock.get = AsyncMock(return_value=None)
        mock.delete = AsyncMock()
        return mock

    @pytest.fixture
    def auth_manager(self, config, mock_redis):
        with patch("ghl_real_estate_ai.security.auth_manager.asyncio.create_task"):
            return AuthManager(config, mock_redis)

    async def test_authenticate_user_success(self, auth_manager):
        """Test successful authentication."""
        # Mock user lookup
        mock_role = MagicMock()
        mock_role.name = "admin"
        mock_role.permissions = []

        user = User(
            user_id="user_123",
            username="testuser",
            email="test@example.com",
            full_name="Test User",
            roles=[mock_role],
            provider=AuthProvider.LOCAL,
        )
        user.password_hash = "$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGGa31KW"  # "password"

        auth_manager._get_user_by_username = AsyncMock(return_value=user)
        auth_manager._verify_password = Mock(return_value=True)
        auth_manager._update_user = AsyncMock()
        # Mock _create_session to bypass Redis/PostgreSQL dependency
        from ghl_real_estate_ai.security.auth_manager import Session, SessionStatus

        mock_session = Session(
            session_id="test_session_123",
            user_id="user_123",
            ip_address="127.0.0.1",
            user_agent="TestAgent",
            created_at=datetime.utcnow(),
            last_active=datetime.utcnow(),
            status=SessionStatus.ACTIVE,
        )
        auth_manager._create_session = AsyncMock(return_value=mock_session)

        result = await auth_manager.authenticate_user("testuser", "password", "127.0.0.1", "TestAgent")

        assert "access_token" in result
        assert result["user"]["username"] == "testuser"
        assert result["session_id"] is not None

    async def test_authenticate_user_locked(self, auth_manager):
        """Test authentication for locked user."""
        user = User(
            user_id="user_123", username="locked", email="", full_name="", roles=[], provider=AuthProvider.LOCAL
        )
        user.locked_until = datetime.utcnow() + timedelta(minutes=10)

        auth_manager._get_user_by_username = AsyncMock(return_value=user)

        with pytest.raises(HTTPException) as exc:
            await auth_manager.authenticate_user("locked", "pass", "1.1.1.1", "agent")

        assert exc.value.status_code == status.HTTP_401_UNAUTHORIZED

    async def test_account_lockout_after_failures(self, auth_manager):
        """Test account lockout logic."""
        user = User(user_id="u1", username="victim", email="", full_name="", roles=[], provider=AuthProvider.LOCAL)

        auth_manager._get_user_by_username = AsyncMock(return_value=user)
        auth_manager._verify_password = Mock(return_value=False)
        auth_manager._update_user = AsyncMock()

        # 3 failures (max_failed_attempts in config fixture)
        for _ in range(3):
            with pytest.raises(HTTPException):
                await auth_manager.authenticate_user("victim", "wrong", "1.1.1.1", "agent")

        assert user.locked_until is not None
        assert user.locked_until > datetime.utcnow()

    async def test_validate_token_expired(self, auth_manager):
        """Test validation of expired session."""
        # This tests the logic in validate_token
        # First we need a real token or mock jwt.decode
        token = "some.token.here"
        payload = {"sub": "u1", "session_id": "s1", "type": "access"}

        mock_role = MagicMock()
        mock_role.name = "agent"
        mock_role.permissions = []

        user = User("u1", "u", "", "", [mock_role], AuthProvider.LOCAL)
        session = Session("s1", "u1", "1.1.1.1", "ua", datetime.utcnow(), datetime.utcnow(), SessionStatus.ACTIVE)

        auth_manager._get_user_by_id = AsyncMock(return_value=user)
        auth_manager._get_session = AsyncMock(return_value=session)
        auth_manager._is_session_expired = Mock(return_value=True)
        auth_manager._revoke_session = AsyncMock()

        with patch("ghl_real_estate_ai.security.auth_manager.jwt.decode", return_value=payload):
            with pytest.raises(HTTPException) as exc:
                await auth_manager.validate_token(token)
            assert exc.value.detail == "Session expired"


@pytest.mark.asyncio
class TestSecurityMiddleware:
    """Tests for SecurityMiddleware."""

    @pytest.fixture(autouse=True)
    def integration_test_lifecycle(self):
        """Override integration test lifecycle to avoid async conflict."""
        yield

    @pytest.fixture
    def mock_components(self):
        # Use AsyncMock for components with async methods
        auth = MagicMock()
        auth.validate_token = AsyncMock()

        rate = MagicMock()
        rate.check_rate_limit = AsyncMock()
        rate.record_request_result = AsyncMock()

        audit = MagicMock()
        audit.log_security_event = AsyncMock()
        audit.log_api_event = AsyncMock()
        audit.log_error = AsyncMock()

        val = MagicMock()
        val.validate_headers = AsyncMock()
        val.validate_query_params = AsyncMock()

        return {"auth": auth, "rate": rate, "role": MagicMock(), "audit": audit, "val": val}

    @pytest.fixture
    def middleware(self, mock_components):
        app = Mock()
        return SecurityMiddleware(
            app,
            mock_components["auth"],
            mock_components["rate"],
            mock_components["role"],
            mock_components["audit"],
            mock_components["val"],
        )

    async def test_dispatch_threat_detection_blocking(self, middleware):
        """Test that malicious activity triggers IP blocking."""
        from starlette.datastructures import URL, QueryParams

        request = MagicMock(spec=Request)
        # Use a very clear pattern that will definitely match sql_patterns
        request.url = URL("/api/leads?id=drop%20table%20users")
        request.query_params = QueryParams("id=drop table users")
        request.method = "GET"
        request.headers = {"user-agent": "EvilBot"}
        request.client = MagicMock()
        request.client.host = "1.2.3.4"
        request.state = MagicMock()

        # Mock call_next (should not be called)
        async def call_next(req):
            return Response()

        response = await middleware.dispatch(request, call_next)

        assert response.status_code == status.HTTP_403_FORBIDDEN
        assert "1.2.3.4" in middleware._blocked_ips

    async def test_exempt_paths(self, middleware):
        """Test that exempt paths skip authentication."""
        from starlette.datastructures import URL, QueryParams

        request = MagicMock(spec=Request)
        request.url = URL("/health")
        request.method = "GET"
        request.headers = {}
        request.query_params = QueryParams("")
        request.client = MagicMock()
        request.client.host = "1.2.7.1"
        request.state = MagicMock()

        # Setup mocks to succeed if called
        middleware.input_validator.validate_headers = AsyncMock()
        middleware.rate_limiter.check_rate_limit = AsyncMock(return_value=MagicMock(allowed=True))

        # Mock call_next to return a 200 OK response
        async def call_next(req):
            return Response(status_code=200)

        response = await middleware.dispatch(request, call_next)

        assert response.status_code == 200
        middleware.auth_manager.validate_token.assert_not_called()

    async def test_authentication_required_fail(self, middleware):
        """Test that protected paths fail without auth."""
        from starlette.datastructures import URL, QueryParams

        request = MagicMock(spec=Request)
        request.url = URL("/api/private")
        request.method = "GET"
        request.headers = {}
        request.query_params = QueryParams("")
        request.client = MagicMock()
        request.client.host = "1.1.1.1"
        request.state = MagicMock()

        middleware.rate_limiter.check_rate_limit = AsyncMock(return_value=MagicMock(allowed=True))

        async def call_next(req):
            return Response()

        response = await middleware.dispatch(request, call_next)

        assert response.status_code == status.HTTP_401_UNAUTHORIZED


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
